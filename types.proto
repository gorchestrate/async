syntax = "proto3";
package core;
option go_package="async";

message WorkflowAPI {        // API for starting the workflow and getting results
    string name = 1;
    string description = 2; // description of this API
    string service = 3;     // service which this workflow belongs to
    string input = 4;       // input type
    string output = 5;      // output type
    string state = 6;       // state type
}

message  Workflow {
    enum Status { // state status is automatically set by API.
        Invalid = 0;  // unset state to identify API misuse faster
        Started = 1;
        Running = 2;
        Finished = 3;
    }
    string id = 1;               // id of the state, should not contain []byte{0} as a substring
    string name = 2;
    string service = 3;
    Status  status = 4;
    repeated Thread threads = 5;
    bytes state = 6;             // When state != nil - the workflow is running. input should be nil
    bytes input = 7;             // When input != nil - the workflow is considered started.  state & output should be nil
    bytes output = 8;            // When output != nil - the workflow is considered finished. input should be nil
    uint64 version = 9;          // version is used to track Workflow changes across time
    uint64 updatedAt = 10;
}


message Thread {
    enum Status { // state status is automatically set by API.
        Invalid = 0; 
        Blocked = 1;  // select is in blocking state and waiting for condition to occur
        Unblocked = 2;       // select is unblocked. It is is ready to be workflowed       
        Aborted = 3;         // workflow has finished before thread was unblocked     
    }
    string id = 1;            // threadID should be unique within Workflow
    string workflow = 2;       // ID of the parent workflow
    string service = 4;         // 'service' is used to divide unblocked thread consumers, so that workflowing of one service doesn't affect the other
    Status status = 6;        
    
    Select select = 5;
    Call call = 12;
    
    uint64 blockedAt = 8;   
    uint64 unblockedAt = 9; 

    // filled after unblocked
    string toStatus = 13;
}

message Type {              // Types are needed to validate async operations (send/recv) and describe API's
    string id = 1;          // if type is not backward-compatible - you have to create new type id
    string description = 2;
    bytes  jsonSchema = 3;  // all type updates should be backward-compatible. You can only add new fields.
    uint64 version = 4;     // track updates to types
}


// Create new workflow using template
message NewWorkflowReq {
    Call  call = 1;
}

// Create new workflow directly
//message  PutWorkflowReq {
//    Workflow workflow = 1;
//}

// Update existing workflow
message  UpdateWorkflowReq {
    Workflow workflow = 1;
    uint64 lockId = 2;
    uint64 unblockedAt = 3;
}

message  Select {
    enum Result { // state status is automatically set by API.
        Invalid = 0; 
        OK = 1;  
        Closed = 2; // operations on closed channels
    }
    
    repeated Case cases = 1;
    
    // filled after unblocked
    uint64 unblockedCase = 2;
    bytes recvData = 3;    
    Result result = 4;
}

message  Case  {
    enum Op { // state status is automatically set by API.
        Invalid = 0; 
        Send = 1;       
        Recv = 2;    
        Time = 3;     // special op to simulate  case <-time.After():
        Default = 5;
    }
    string toStatus = 1;
    Op op = 2;
    string chan = 3;
    uint64 time = 4; // for Op_Time
    bytes data = 5; // for Op_Send
    string dataType = 6;  // for Op_Send
}

message  Call {
    string id = 1;
    string name = 2;
    bytes input = 3;
    string inputType = 4;
    string outputType = 5;

    // filled after unblocked
    bytes output = 6;
}



message  Channel {
    string id = 1;
    string dataType = 2;
    bool closed = 3;
    uint64 bufSize = 4;
    uint64 bufMaxSize = 5;
}

message  ChanSelect {
    uint64 blockedAt = 1;
    uint64 case = 2;    
}

message  WaitCallIndex {
    uint64 blockedAt = 1;
    string workflowsId = 2;
}

message  BufData {
	//string Workflow     = 1;
	//string Select    = 2; 
	//string Group     = 3; 
	//string ToStatus  = 4; 
    string Chan = 1;
	bytes Data       = 5; 
    uint64 clock     = 6;
}

message Empty {
}

message RegisterWorkflowHandlerReq {
    string service = 1;
    int64 pool = 2;
    int64 pollIntervalMs = 3;
}

message LockedWorkflow {
    Workflow workflow = 1;
    Thread thread = 2;
    uint64 lockId = 3;
}

message MakeChanReq {
    Channel chan = 1;
}

message CloseChanReq {
    repeated string ids = 1;
}

message DeleteChanReq {
    repeated string ids = 1;
}

message ListChansReq {
    string id = 1;
    string from = 2;
    uint64 limit = 3;
}

message ListChansResp {
    repeated Channel chans = 1;
}

message ListTypesReq {
    string id = 1;
    string from = 2;
    uint64 limit = 3;
}

message ListTypesResp {
    repeated Type types = 1;
}

message ListWorkflowAPIsReq {
    string id = 1;
    string from = 2;
    uint64 limit = 3;
}

message ListWorkflowAPIsResp {
    repeated WorkflowAPI apis = 1;
}

message GetWorkflowReq {
    string id = 1;
}

message LockWorkflowReq {
    string id = 1;
    uint64 seconds = 2;
    // TODO: Lock for specified amount of time
    // TODO: allow to extend lock time
}

message ExtendLockReq {
    string id = 1;
    uint64 lockid = 2;
    uint64 seconds = 3;
    // TODO: Lock for specified amount of time
    // TODO: allow to extend lock time
}

message ListenWorkflowsUpdatesReq {
    uint64 from = 1;
    string filter = 3;
}

message FindWorkflowsReq {
    uint64 from = 1;
    uint64 to = 2;
    uint64 limit = 3;
    uint64 scanlimit = 5;
    string filter = 4;
}

message FindWorkflowsResp {
    repeated Workflow workflows = 1;
}

message WorkflowEvent {
    Workflow workflow = 1;
    Thread thread = 2;
}


service Runtime {

    // Create new workflow using specified Input and API to call
    // If workflow is already created - error will be returned
    rpc NewWorkflow(NewWorkflowReq) returns (Empty);

    // Create new workflow directly without API
    // If workflow was already created - error will be returned
    //rpc PutWorkflow(PutWorkflowReq) returns (Empty);

    // Update previously locked workflow with the new state
    // This operation may fail if some of selects were removed, while being unblocked.
    rpc UpdateWorkflow(UpdateWorkflowReq) returns (Empty);

    // Listen for unblocked workflows, workflow events and then updated workflows.
    // Only 1 client can receive a workflow at a time
    // For each Workflow - all updates to it are executed one by one.
    // If multiple clients connect with the same "Service" name - events are randomly distributed between them,
    // however if one of the clients becomes slow - it may slowdown other clients with same "Service" name
    // Clients with different "Service" name do not affect each other. They have separate execution queues and 
    // update distribution pool
    rpc RegisterWorkflowHandler(RegisterWorkflowHandlerReq) returns (stream LockedWorkflow);

    // Get current workflow
    rpc GetWorkflow(GetWorkflowReq) returns (Workflow);

    // Manually lock workflow to change it's state via UpdateWorkflow
    rpc LockWorkflow(LockWorkflowReq) returns (LockedWorkflow);

    // Manually lock workflow to change it's state via UpdateWorkflow
    rpc ExtendLock(ExtendLockReq) returns (Empty);
    

    // Listen for updates states. You can use this to sync data with other DB's, for ex. Search / Reports / etc.
    rpc ListenWorkflowsUpdates(ListenWorkflowsUpdatesReq) returns (stream WorkflowEvent);

    rpc FindWorkflows(FindWorkflowsReq) returns (FindWorkflowsResp);

    rpc MakeChan(MakeChanReq) returns (Empty);

    rpc ListChans(ListChansReq) returns (ListChansResp);

    rpc CloseChan(CloseChanReq) returns (Empty);

    rpc DeleteChan(DeleteChanReq) returns (Empty);


    rpc PutType(Type) returns (Empty);
    
    rpc ListTypes(ListTypesReq) returns (ListTypesResp);

    rpc DeleteType(Type) returns (Empty);


    rpc PutWorkflowAPI(WorkflowAPI) returns (Empty);

    rpc ListWorkflowAPIs(ListWorkflowAPIsReq) returns (ListWorkflowAPIsResp);    

    rpc DeleteWorkflowAPI(WorkflowAPI) returns (Empty);    
}